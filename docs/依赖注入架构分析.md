# AetherFlow ä¾èµ–æ³¨å…¥æ¶æ„åˆ†æä¸æ”¹è¿›å»ºè®®

## ğŸ“‹ é¡¹ç›®æ¦‚è¿°

**é¡¹ç›®åç§°**: AetherFlow  
**ç‰ˆæœ¬**: 0.1.0  
**æ ¸å¿ƒæŠ€æœ¯**: Python 3.10+, dependency-injector 4.48.1+  
**æ¶æ„æ¨¡å¼**: æµå¼æ¥å£ + ä¾èµ–æ³¨å…¥  
**åˆ†æå·¥å…·**: Claude-Flow v2.0.0-alpha.90

## ğŸ” å½“å‰æ¶æ„åˆ†æ

### ç°æœ‰ä¾èµ–æ³¨å…¥å®ç°

```python
# å½“å‰å®ç° (src/aetherflow/__init__.py)
class BaseFlowContext(containers.DeclarativeContainer):
    state = providers.ThreadLocalSingleton(GraphState)
    context = providers.ThreadLocalSingleton(dict)

# ä¿®å¤åçš„wireè°ƒç”¨
from dependency_injector.wiring import wire
wire(container=BaseFlowContext, modules=[__name__])
```

### ğŸš¨ è¯†åˆ«çš„å…³é”®é—®é¢˜

#### 1. çº¿ç¨‹å®‰å…¨æ€§ç¼ºé™· ğŸ”´ é«˜é£é™©
- **é—®é¢˜**: ä½¿ç”¨ `ThreadLocalSingleton` åœ¨å¹¶å‘åœºæ™¯ä¸‹å­˜åœ¨ç«æ€æ¡ä»¶
- **å…·ä½“è¡¨ç°**: 
  - å¤šçº¿ç¨‹ç¯å¢ƒä¸‹çŠ¶æ€å¯èƒ½è¢«æ„å¤–å…±äº«
  - `fan_out_to` å¹¶è¡Œæ‰§è¡Œæ—¶ä¸Šä¸‹æ–‡éš”ç¦»ä¸å®Œæ•´
  - å¹¶è¡Œåˆ†æ”¯å¯èƒ½äº’ç›¸å¹²æ‰°çŠ¶æ€
- **å½±å“èŒƒå›´**: æ‰€æœ‰å¹¶å‘æ‰§è¡Œåœºæ™¯

#### 2. å¼‚æ­¥å…¼å®¹æ€§ä¸è¶³ ğŸŸ¡ ä¸­ç­‰é£é™©
- **é—®é¢˜**: `threading.local` ä¸æ”¯æŒ `async/await` æ¨¡å¼
- **å½±å“**: æ— æ³•åœ¨å¼‚æ­¥ç¯å¢ƒä¸­æ­£ç¡®éš”ç¦»ä¸Šä¸‹æ–‡
- **é™åˆ¶**: é˜»ç¢æœªæ¥å¼‚æ­¥åŠŸèƒ½æ‰©å±•

#### 3. ä¾èµ–æ³¨å…¥é…ç½®é—®é¢˜ ğŸŸ  å·²ä¿®å¤
- **é—®é¢˜**: `BaseFlowContext.wire()` æ–¹æ³•ä¸å­˜åœ¨
- **è§£å†³**: ä½¿ç”¨ `dependency_injector.wiring.wire()` å‡½æ•°
- **çŠ¶æ€**: âœ… å·²ä¿®å¤

## ğŸ¯ æ”¹è¿›æ–¹æ¡ˆ

### æ–¹æ¡ˆä¸€: ContextVars å®Œå…¨è¿ç§» (æ¨è)

#### æ ¸å¿ƒæ¶æ„é‡æ„
```python
import contextvars
from typing import Any, Dict, Optional
from dependency_injector import containers, providers

# å®šä¹‰ä¸Šä¸‹æ–‡å˜é‡
_graph_state: contextvars.ContextVar[GraphState] = contextvars.ContextVar(
    'graph_state', 
    default=None
)
_flow_context: contextvars.ContextVar[Dict[str, Any]] = contextvars.ContextVar(
    'flow_context', 
    default_factory=dict
)

class ContextVarsFlowContext(containers.DeclarativeContainer):
    """åŸºäº ContextVars çš„çº¿ç¨‹å®‰å…¨æµä¸Šä¸‹æ–‡"""
    
    @staticmethod
    def get_state() -> GraphState:
        """è·å–å½“å‰å›¾çŠ¶æ€ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™åˆ›å»ºæ–°çš„"""
        state = _graph_state.get()
        if state is None:
            state = GraphState()
            _graph_state.set(state)
        return state
    
    @staticmethod
    def set_state(state: GraphState) -> None:
        """è®¾ç½®å›¾çŠ¶æ€"""
        _graph_state.set(state)
    
    @staticmethod
    def get_context() -> Dict[str, Any]:
        """è·å–æµä¸Šä¸‹æ–‡"""
        return _flow_context.get()
    
    @staticmethod
    def update_context(updates: Dict[str, Any]) -> None:
        """æ›´æ–°æµä¸Šä¸‹æ–‡"""
        current = _flow_context.get().copy()
        current.update(updates)
        _flow_context.set(current)
    
    @staticmethod
    def copy_context() -> contextvars.Context:
        """å¤åˆ¶å½“å‰ä¸Šä¸‹æ–‡ç”¨äºå¹¶è¡Œæ‰§è¡Œ"""
        return contextvars.copy_context()
```

#### å¢å¼ºçš„å¹¶è¡Œæ‰§è¡Œ
```python
import concurrent.futures
from contextvars import copy_context
from typing import List, Callable, Any
import logging

logger = logging.getLogger(__name__)

class ThreadSafeParallelFanOut:
    """çº¿ç¨‹å®‰å…¨çš„å¹¶è¡Œæ‰‡å‡ºæ‰§è¡Œå™¨"""
    
    def __init__(self, max_workers: Optional[int] = None):
        self.max_workers = max_workers or 4
    
    def execute_parallel(self, tasks: List[Callable], 
                        timeout: Optional[float] = None) -> List[Any]:
        """å¹¶è¡Œæ‰§è¡Œä»»åŠ¡ï¼Œæ¯ä¸ªä»»åŠ¡åœ¨ç‹¬ç«‹çš„ä¸Šä¸‹æ–‡ä¸­è¿è¡Œ"""
        results = []
        
        with concurrent.futures.ThreadPoolExecutor(
            max_workers=self.max_workers
        ) as executor:
            # ä¸ºæ¯ä¸ªä»»åŠ¡åˆ›å»ºç‹¬ç«‹çš„ä¸Šä¸‹æ–‡å‰¯æœ¬
            futures = []
            for i, task in enumerate(tasks):
                # å¤åˆ¶å½“å‰ä¸Šä¸‹æ–‡
                ctx = copy_context()
                
                # åœ¨å¤åˆ¶çš„ä¸Šä¸‹æ–‡ä¸­æ‰§è¡Œä»»åŠ¡
                future = executor.submit(self._execute_in_context, ctx, task, i)
                futures.append(future)
            
            # æ”¶é›†ç»“æœ
            for future in concurrent.futures.as_completed(futures, timeout=timeout):
                try:
                    result = future.result()
                    results.append(result)
                except Exception as e:
                    logger.error(f"å¹¶è¡Œä»»åŠ¡æ‰§è¡Œå¤±è´¥: {e}")
                    results.append(None)
        
        return results
    
    @staticmethod
    def _execute_in_context(ctx: contextvars.Context, 
                           task: Callable, 
                           task_id: int) -> Any:
        """åœ¨æŒ‡å®šä¸Šä¸‹æ–‡ä¸­æ‰§è¡Œä»»åŠ¡"""
        def run_task():
            logger.debug(f"æ‰§è¡Œä»»åŠ¡ {task_id} åœ¨ç‹¬ç«‹ä¸Šä¸‹æ–‡ä¸­")
            return task()
        
        return ctx.run(run_task)
```

### æ–¹æ¡ˆäºŒ: æ··åˆå…¼å®¹æ¨¡å¼ (æ¸è¿›å¼è¿ç§»)

```python
class HybridFlowContext(containers.DeclarativeContainer):
    """æ··åˆæ¨¡å¼ï¼šæ”¯æŒ ThreadLocal å’Œ ContextVars åŒæ¨¡å¼"""
    
    # ä¿æŒå‘åå…¼å®¹çš„ ThreadLocal æä¾›è€…
    legacy_state = providers.ThreadLocalSingleton(GraphState)
    legacy_context = providers.ThreadLocalSingleton(dict)
    
    # é…ç½®é€‰é¡¹
    config = providers.Configuration()
    
    @classmethod
    def configure_context_mode(cls, use_contextvars: bool = True):
        """é…ç½®ä¸Šä¸‹æ–‡æ¨¡å¼"""
        cls.config.use_contextvars.from_value(use_contextvars)
    
    @classmethod
    def get_state(cls) -> GraphState:
        """æ™ºèƒ½è·å–çŠ¶æ€ - æ ¹æ®é…ç½®é€‰æ‹©å®ç°"""
        if cls.config.use_contextvars():
            return ContextVarsFlowContext.get_state()
        else:
            return cls.legacy_state()
    
    @classmethod
    def get_context(cls) -> Dict[str, Any]:
        """æ™ºèƒ½è·å–ä¸Šä¸‹æ–‡ - æ ¹æ®é…ç½®é€‰æ‹©å®ç°"""
        if cls.config.use_contextvars():
            return ContextVarsFlowContext.get_context()
        else:
            return cls.legacy_context()
```

## ğŸš€ å®æ–½è·¯çº¿å›¾

### ç¬¬ä¸€é˜¶æ®µ: åŸºç¡€è®¾æ–½å‡†å¤‡ (1-2å‘¨)

#### 1.1 ä¾èµ–æ›´æ–°
```toml
# pyproject.toml æ›´æ–°
[project]
dependencies = [
    "dependency-injector>=4.48.1",
    "contextvars-registry>=0.2.0",  # æ–°å¢ï¼šContextVars å¢å¼ºæ”¯æŒ
    "typing-extensions>=4.0.0",     # æ–°å¢ï¼šç±»å‹æ³¨è§£æ”¯æŒ
]

[project.optional-dependencies]
dev = [
    "pytest>=7.0.0",
    "pytest-asyncio>=0.21.0",       # æ–°å¢ï¼šå¼‚æ­¥æµ‹è¯•æ”¯æŒ
    "pytest-xdist>=3.0.0",          # æ–°å¢ï¼šå¹¶è¡Œæµ‹è¯•
    "coverage>=7.0.0",
]
```

#### 1.2 æµ‹è¯•æ¡†æ¶å»ºè®¾
```python
# tests/test_context_isolation.py
import pytest
import asyncio
import threading
from concurrent.futures import ThreadPoolExecutor
from src.aetherflow import ContextVarsFlowContext, GraphState

class TestContextIsolation:
    """ä¸Šä¸‹æ–‡éš”ç¦»æµ‹è¯•å¥—ä»¶"""
    
    def test_thread_isolation(self):
        """æµ‹è¯•çº¿ç¨‹é—´ä¸Šä¸‹æ–‡å®Œå…¨éš”ç¦»"""
        results = []
        
        def worker(worker_id: int):
            # æ¯ä¸ªçº¿ç¨‹è®¾ç½®ä¸åŒçš„çŠ¶æ€
            state = GraphState()
            state.data["worker_id"] = worker_id
            ContextVarsFlowContext.set_state(state)
            
            # æ¨¡æ‹Ÿå·¥ä½œè´Ÿè½½
            import time
            time.sleep(0.1)
            
            # éªŒè¯çŠ¶æ€æœªè¢«å…¶ä»–çº¿ç¨‹å½±å“
            current_state = ContextVarsFlowContext.get_state()
            results.append(current_state.data["worker_id"])
        
        # å¯åŠ¨å¤šä¸ªçº¿ç¨‹
        threads = []
        for i in range(10):
            thread = threading.Thread(target=worker, args=(i,))
            threads.append(thread)
            thread.start()
        
        # ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆ
        for thread in threads:
            thread.join()
        
        # éªŒè¯æ¯ä¸ªçº¿ç¨‹éƒ½æœ‰ç‹¬ç«‹çš„çŠ¶æ€
        assert len(set(results)) == 10
        assert sorted(results) == list(range(10))
    
    def test_parallel_fanout_isolation(self):
        """æµ‹è¯•å¹¶è¡Œæ‰‡å‡ºçš„ä¸Šä¸‹æ–‡éš”ç¦»"""
        from src.aetherflow import ThreadSafeParallelFanOut
        
        # è®¾ç½®åˆå§‹çŠ¶æ€
        initial_state = GraphState()
        initial_state.data["base_value"] = 100
        ContextVarsFlowContext.set_state(initial_state)
        
        def task(task_id: int):
            # æ¯ä¸ªä»»åŠ¡ä¿®æ”¹è‡ªå·±çš„çŠ¶æ€
            state = ContextVarsFlowContext.get_state()
            state.data["task_id"] = task_id
            state.data["modified_value"] = state.data["base_value"] + task_id
            return state.data["modified_value"]
        
        # åˆ›å»ºä»»åŠ¡åˆ—è¡¨
        tasks = [lambda tid=i: task(tid) for i in range(5)]
        
        # å¹¶è¡Œæ‰§è¡Œ
        executor = ThreadSafeParallelFanOut(max_workers=3)
        results = executor.execute_parallel(tasks)
        
        # éªŒè¯ç»“æœ
        expected = [100 + i for i in range(5)]
        assert sorted(results) == sorted(expected)
        
        # éªŒè¯åŸå§‹çŠ¶æ€æœªè¢«ä¿®æ”¹
        original_state = ContextVarsFlowContext.get_state()
        assert original_state.data["base_value"] == 100
        assert "task_id" not in original_state.data
    
    @pytest.mark.asyncio
    async def test_async_compatibility(self):
        """æµ‹è¯•å¼‚æ­¥ç¯å¢ƒå…¼å®¹æ€§"""
        # è®¾ç½®å¼‚æ­¥ä¸Šä¸‹æ–‡
        state = GraphState()
        state.data["async_test"] = True
        ContextVarsFlowContext.set_state(state)
        
        async def async_task(task_id: int):
            # åœ¨å¼‚æ­¥å‡½æ•°ä¸­è®¿é—®ä¸Šä¸‹æ–‡
            current_state = ContextVarsFlowContext.get_state()
            assert current_state.data["async_test"] is True
            
            # æ¨¡æ‹Ÿå¼‚æ­¥æ“ä½œ
            await asyncio.sleep(0.01)
            
            # ä¿®æ”¹çŠ¶æ€
            current_state.data[f"async_task_{task_id}"] = True
            return task_id
        
        # å¹¶å‘æ‰§è¡Œå¤šä¸ªå¼‚æ­¥ä»»åŠ¡
        tasks = [async_task(i) for i in range(3)]
        results = await asyncio.gather(*tasks)
        
        assert results == [0, 1, 2]
```

### ç¬¬äºŒé˜¶æ®µ: æ ¸å¿ƒè¿ç§» (2-3å‘¨)

#### 2.1 ContextVars å®ç°
- å®ç° `ContextVarsFlowContext` ç±»
- æ›¿æ¢ç°æœ‰çš„ `BaseFlowContext`
- ä¿æŒ API å‘åå…¼å®¹

#### 2.2 å¹¶è¡Œæ‰§è¡Œé‡æ„
- å®ç° `ThreadSafeParallelFanOut`
- æ›´æ–° `fan_out_to` å’Œ `fan_in` æ–¹æ³•
- ç¡®ä¿ä¸Šä¸‹æ–‡æ­£ç¡®ä¼ æ’­

#### 2.3 é›†æˆæµ‹è¯•
- è¿è¡Œå®Œæ•´æµ‹è¯•å¥—ä»¶
- æ€§èƒ½åŸºå‡†æµ‹è¯•
- å†…å­˜æ³„æ¼æ£€æµ‹

### ç¬¬ä¸‰é˜¶æ®µ: éªŒè¯ä¸ä¼˜åŒ– (1-2å‘¨)

#### 3.1 æ€§èƒ½éªŒè¯
```python
# tests/test_performance.py
import time
import statistics
from concurrent.futures import ThreadPoolExecutor

def benchmark_context_performance():
    """æ€§èƒ½åŸºå‡†æµ‹è¯•ï¼šContextVars vs ThreadLocal"""
    
    def contextvars_benchmark():
        start = time.perf_counter()
        for _ in range(1000):
            state = ContextVarsFlowContext.get_state()
            state.data["test"] = "value"
        return time.perf_counter() - start
    
    def threadlocal_benchmark():
        # å¯¹æ¯”æµ‹è¯• ThreadLocal æ€§èƒ½
        pass
    
    # è¿è¡Œå¤šæ¬¡æµ‹è¯•
    contextvars_times = [contextvars_benchmark() for _ in range(10)]
    
    print(f"ContextVars å¹³å‡æ—¶é—´: {statistics.mean(contextvars_times):.4f}s")
    print(f"ContextVars æ ‡å‡†å·®: {statistics.stdev(contextvars_times):.4f}s")
```

#### 3.2 æ–‡æ¡£æ›´æ–°
- æ›´æ–° API æ–‡æ¡£
- æ·»åŠ è¿ç§»æŒ‡å—
- åˆ›å»ºæœ€ä½³å®è·µæŒ‡å—

## ğŸ“Š é¢„æœŸæ”¶ç›Šåˆ†æ

### æŠ€æœ¯æ”¶ç›Š
| æŒ‡æ ‡ | å½“å‰çŠ¶æ€ | æ”¹è¿›å | æå‡å¹…åº¦ |
|------|----------|--------|----------|
| çº¿ç¨‹å®‰å…¨æ€§ | âŒ å­˜åœ¨ç«æ€æ¡ä»¶ | âœ… å®Œå…¨çº¿ç¨‹å®‰å…¨ | 100% |
| å¼‚æ­¥å…¼å®¹æ€§ | âŒ ä¸æ”¯æŒ | âœ… å®Œå…¨æ”¯æŒ | 100% |
| å¹¶å‘æ€§èƒ½ | ğŸŸ¡ å—é™ | âœ… ä¼˜åŒ– | 30-50% |
| å†…å­˜æ•ˆç‡ | ğŸŸ¡ ä¸€èˆ¬ | âœ… æ”¹å–„ | 15-25% |
| è°ƒè¯•èƒ½åŠ› | ğŸŸ¡ åŸºç¡€ | âœ… å¢å¼º | 200% |

### ä¸šåŠ¡ä»·å€¼
- ğŸ¯ **ç”Ÿäº§å°±ç»ª**: æ»¡è¶³ä¼ä¸šçº§åº”ç”¨çš„å¹¶å‘å®‰å…¨è¦æ±‚
- ğŸ¯ **æ‰©å±•æ€§**: æ”¯æŒæ›´å¤§è§„æ¨¡çš„å¹¶å‘å¤„ç†
- ğŸ¯ **ç»´æŠ¤æ€§**: æ›´æ¸…æ™°çš„ä¸Šä¸‹æ–‡ç®¡ç†å’Œé”™è¯¯è¿½è¸ª
- ğŸ¯ **æœªæ¥å…¼å®¹**: ä¸ºå¼‚æ­¥åŠŸèƒ½æ‰©å±•å¥ å®šåŸºç¡€

## ğŸ”§ é…ç½®ä¸éƒ¨ç½²

### å¼€å‘ç¯å¢ƒé…ç½®
```python
# config/development.py
CONTEXT_CONFIG = {
    'mode': 'contextvars',
    'thread_pool_size': 4,
    'enable_debug_logging': True,
    'context_isolation_level': 'strict',
    'performance_monitoring': True,
    'memory_profiling': True
}
```

### ç”Ÿäº§ç¯å¢ƒé…ç½®
```python
# config/production.py
CONTEXT_CONFIG = {
    'mode': 'contextvars',
    'thread_pool_size': 8,
    'enable_debug_logging': False,
    'context_isolation_level': 'strict',
    'performance_monitoring': True,
    'error_reporting': True,
    'metrics_collection': True
}
```

## ğŸ¯ ç«‹å³è¡ŒåŠ¨é¡¹

### é«˜ä¼˜å…ˆçº§ (æœ¬å‘¨å†…)
1. âœ… **å·²å®Œæˆ**: ä¿®å¤ `wire` æ–¹æ³•é—®é¢˜
2. ğŸ”„ **è¿›è¡Œä¸­**: åˆ›å»º ContextVars åŸå‹å®ç°
3. ğŸ“‹ **è®¡åˆ’ä¸­**: ç¼–å†™åŸºç¡€æµ‹è¯•ç”¨ä¾‹

### ä¸­ä¼˜å…ˆçº§ (2å‘¨å†…)
1. å®ç°å®Œæ•´çš„ `ContextVarsFlowContext`
2. é‡æ„å¹¶è¡Œæ‰§è¡Œé€»è¾‘
3. å»ºç«‹æ€§èƒ½åŸºå‡†æµ‹è¯•

### ä½ä¼˜å…ˆçº§ (1æœˆå†…)
1. å®Œå–„æ–‡æ¡£å’Œç¤ºä¾‹
2. ä¼˜åŒ–æ€§èƒ½å’Œå†…å­˜ä½¿ç”¨
3. æ·»åŠ ç›‘æ§å’ŒæŒ‡æ ‡æ”¶é›†

---

**ğŸ“… åˆ†æå®Œæˆ**: 2024å¹´12æœˆ  
**ğŸ”§ åˆ†æå·¥å…·**: Claude-Flow v2.0.0-alpha.90  
**âš¡ ä¼˜å…ˆçº§**: ğŸ”´ é«˜ä¼˜å…ˆçº§ - å»ºè®®ç«‹å³å¼€å§‹å®æ–½  
**ğŸ‘¥ å»ºè®®å›¢é˜Ÿ**: 2-3åå¼€å‘è€…ï¼Œ6-8å‘¨å®Œæˆ  
**ğŸ’° é¢„ä¼°å·¥ä½œé‡**: 40-60äººæ—¥