# AetherFlow: 一个为Pythonic AI Agent框架提炼的架构蓝图

AetherFlow的设计旨在实现一个核心目标：将工业级系统的设计原则与Python语言的表达美学相结合，提供一个既强大又极具开发者幸福感的平台。本设计采纳了务实的工程约束，专注于构建一个健壮、同步的核心，同时为未来的异步、安全和高级韧性功能预留了清晰的演进路径。

## I. 核心原语：流式接口 (Fluent Interface) DSL

AetherFlow的开发者体验（DX）始于其独特的、利用方法链构建的内部领域特定语言（DSL）。这种“流式接口”（Fluent Interface）的设计旨在让工作流的定义像书写链式调用一样自然和清晰。

**V1版本的核心方法：**

| 方法 | 语义 | 示例 |
| :--- | :--- | :--- |
| `.then(node)` | **顺序执行**: 将控制流和完整的输出从当前节点传递到下一个节点。 | `research.then(summarize)` |
| `.fan_out_to(nodes)` | **并行扇出 (Fan-out)**: 将一个节点的输出（作为只读状态）分发给多个并行执行的节点列表。 | `start_node.fan_out_to([task_a, task_b])` |
| `.fan_in(node)` | **并行汇入 (Fan-in)**: 等待所有上游并行节点完成，并将其各自的独立结果汇集，然后传递给下游的聚合节点。 | `.fan_in(aggregate)` |
| `.branch_on(conditions)` | **条件分支**: 根据当前节点的布尔输出，从一个字典中选择一个路径执行。 | `check_condition.branch_on({True: path_a, False: path_b})` |
| `.repeat(times)` | **固定次数循环**: 将一个节点连续执行N次。每次迭代的输入是上一次迭代的输出。 | `refine_draft.repeat(3)` |

**循环语义的澄清 (约束 #2):**

在AetherFlow V1中，`.repeat()` 方法仅支持与整数配对，表示固定次数的循环。例如，`refine_draft.repeat(3)`。其执行逻辑如下：
1.  `refine_draft` 接收其上游节点（例如 `write_draft`）的输出作为第一次执行的输入。
2.  第二次执行时，它接收第一次执行的输出作为输入。
3.  第三次执行时，它接收第二次执行的输出作为输入。
4.  整个循环完成后，第三次执行的最终输出将被传递给下游节点。

.map_to([items])` 这种映射（Map）模式将不被支持，以保持循环语义的单一和清晰。

**条件性退出循环 (Conditional Loop Exit):**

为了在保持简单性的同时增加灵活性，V1将支持一种机制，允许节点在循环内部决定提前终止循环。这是通过一个特殊的返回信号实现的。

1.  **引入 `LoopControl` 信号**: 框架将提供一个特殊的枚举或对象，例如 `AetherFlow.LoopControl.BREAK`。
2.  **节点内部逻辑**: 在一个被 `.repeat()` 的节点内部，开发者可以编写逻辑。如果满足某个条件，函数可以 `return AetherFlow.LoopControl.BREAK`。
3.  **执行引擎的行为**:
    *   当执行引擎收到这个 `BREAK` 信号时，它会立即停止当前的 `repeat` 循环。
    *   传递给下游节点的 `GraphState` 将保持为循环中断前**最后一次成功执行**的状态。`BREAK`信号本身不会被传递下去。

**示例代码:**

```python
from aetherflow import node, LoopControl, GraphState

@node
def refine_until_satisfied(state: GraphState) -> GraphState | LoopControl:
    content = state.get("content")
    refined_content, is_satisfied = some_refinement_logic(content)

    if is_satisfied:
        # 条件满足，返回BREAK信号以终止循环
        return LoopControl.BREAK
    else:
        # 条件不满足，更新状态并继续循环
        state["content"] = refined_content
        return state

# 这个循环最多执行5次，但如果refine_until_satisfied内部逻辑满足，
# 可能会提前退出。
flow = start_node.then(refine_until_satisfied.repeat(5)).then(final_step)
```

这种设计既保留了 `.repeat(N)` 作为上限和“安全网”的清晰语义，又赋予了开发者在节点内部实现复杂退出逻辑的能力，而无需引入新的DSL方法。

## II. 状态与并发：不可变扇出/汇入模式 (Immutable Fan-Out/Fan-In)

这是对并发场景下状态管理的核心设计决策，旨在保证行为的确定性和优雅性。

### 并发执行的挑战
当一个工作流并行执行时（`start_node.fan_out_to([task_a, task_b])`），如果 `task_a` 和 `task_b` 都试图修改同一个共享状态对象，就会产生竞态条件，导致结果不可预测。

### AetherFlow的解决方案 (约束 #3)
我们引入一个优雅且安全的模式来解决这个问题：

1.  **状态冻结 (State Freezing)**: 当执行进入一个并行分支（`.fan_out_to()`）时，框架传递给所有并行节点的 `GraphState` 将被视为**只读（Frozen）**。在这些并行节点内部，任何试图直接修改传入 `GraphState` 的操作都将引发一个运行时错误。这从根本上杜绝了并发写入的风险。

2.  **隔离的节点输出 (Isolated Node Results)**: 并行节点不应更新共享状态，而应返回一个独立的、自包含的结果。这个结果可以是任何可序列化的Python对象（如字典、Pydantic模型）。它代表了该节点独立完成的工作成果。

3.  **结构化结果汇集 (Structured Result Aggregation)**: 当并行分支通过 `.fan_in()` 方法汇合时，下游的聚合节点（例如 `aggregate`）的函数签名会比较特殊。它将接收两个参数：
    *   `state: GraphState`: 这是并行分支开始之前的那个原始的、未被修改的 `GraphState`。
    *   `parallel_results: dict[str, Any]`: 这是一个字典，其中包含了所有并行分支的返回结果，键是节点的名称，值是节点的独立输出。

**示例代码：**
```python
# 并行节点定义 (只读状态，返回独立结果)
@node
def task_a(state: GraphState) -> dict:
    # state['some_value'] 可以被读取
    # state['some_value'] = 'new'  <-- 这将抛出错误
    return {"summary": "Result from A"}

@node
def task_b(state: GraphState) -> dict:
    return {"image_url": "http://example.com/img.png"}

# 聚合节点定义 (接收原始状态和并行结果)
@node
def aggregate(state: GraphState, parallel_results: dict) -> GraphState:
    # parallel_results 的内容会是:
    # {
    #   "task_a": {"summary": "Result from A"},
    #   "task_b": {"image_url": "http://example.com/img.png"}
    # }
    state['summary'] = parallel_results['task_a']['summary']
    state['image_url'] = parallel_results['task_b']['image_url']
    return state # 返回更新后的状态

# 工作流定义
flow = start_node.fan_out_to([task_a, task_b]).fan_in(aggregate)
```

这种模式将并发执行（计算）和状态更新（合并）清晰地分离开来。它强制实现了一种更函数式的、可预测的并发模型，完美地解决了状态冲突问题，同时保持了DSL的优雅。

## III. 节点设计：专注与兼容

AetherFlow的节点是纯粹的Python函数，通过装饰器来增强其功能，同时保持业务逻辑的整洁。

**核心装饰器：**
*   `@node`: 声明一个函数为图节点。
*   `@retry`: 提供健壮的重试逻辑。
*   `@cache`: 提供带过期时间的缓存。
*   `@validate`: 使用Pydantic模型强制执行输入/输出模式。
*   `@inject`: 标记需要由DI容器注入的依赖项。

### 兼容性设计 (约束 #4)
AetherFlow的V1版本将是一个**同步执行框架**。这简化了核心引擎的设计，使其更加稳定和易于理解。

*   **异步兼容性**: 框架本身不提供异步事件循环。但是，如果一个节点需要执行异步操作，它可以在其内部逻辑中使用 `asyncio.run()` 来管理自己的事件循环。从框架的角度看，它仍然是一个阻塞的、同步的调用。
*   **流式输出兼容性**: 框架不直接处理流式（`yield`）输出。一个节点如果是生成器函数，执行引擎会完整地迭代它，并将最终的 `return` 值（或最后一个 `yield` 的值）作为该节点的最终输出，用于状态更新和传递给下游。这意味着节点内部可以实现流式逻辑（例如，将内容流式写入文件），但节点之间的交互是基于最终结果的。

## IV. 演进路径：为未来而设计

根据您的指导，我们将一些复杂的企业级功能明确地划定为V1之后的可演进方向。当前的设计将确保为这些未来的功能提供必要的“钩子”，使得集成它们成为可能，而无需对核心架构进行颠覆性改造。

### 计划中的后续演进 (约束 #5 & #6)

*   **高级韧性 (Advanced Resiliency):**
    *   **检查点 (Checkpointing)**: `GraphState` 被设计为可序列化的，这是实现检查点的先决条件。未来可以在执行引擎的节点切换处增加一个持久化钩子，将状态保存到外部存储。
    *   **Saga模式**: `@compensate` 装饰器可以被引入，用于将一个节点注册为另一个节点的补偿操作。执行引擎可以维护一个已完成事务的日志，并在发生不可恢复的错误时，反向调用这些补偿节点。

*   **安全与治理 (Security & Governance):**
    *   **沙箱化执行**: 依赖注入系统是实现安全性的关键入口。未来可以定义一个标准的 `CodeExecutor` 接口，并提供一个基于Docker或gVisor的沙箱化实现。通过DI容器替换实现，就可以在不修改任何业务逻辑的情况下，将代码执行切换到安全环境中。
    *   **能力管理 (Agent RBAC)**: 同样，通过DI注入的API客户端可以被包裹一层权限检查代理。这个代理会在执行API调用前，查询一个策略引擎，以验证当前智能体是否拥有执行该操作的权限。

通过这种分阶段的方法，AetherFlow可以首先专注于提供一个无与伦比的、简洁而强大的核心编排体验，同时建立一个坚实的基础，以便在未来平滑地演进为一个功能完备的企业级AI Agent平台。